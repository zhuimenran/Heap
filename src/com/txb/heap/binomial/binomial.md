参考：https://www.cnblogs.com/skywang12345/p/3655900.html

##二项树的介绍
二项树的定义
###binTree.jpg
二项堆是二项树的集合。在了解二项堆之前，先对二项树进行介绍。

二项树是一种递归定义的有序树。它的递归定义如下：
(01) 二项树B0只有一个结点；
(02) 二项树Bk由两棵二项树B(k-1)组成的，其中一棵树是另一棵树根的最左孩子。
上图的B0、B1、B2、B3、B4都是二项树。对比前面提到的二项树的定义：B0只有一个节点，B1由两个B0所组成，B2由两个B1所组成，B3由两个B2所组成，B4由两个B3所组成；而且，当两颗相同的二项树组成另一棵树时，其中一棵树是另一棵树的最左孩子。

##二项树的性质

二项树有以下性质：
[性质一] Bk共有2k个节点。
[性质二] Bk的高度为k。
[性质三] Bk在深度i处恰好有C(k,i)个节点，其中i=0,1,2,...,k。
[性质四] 根的度数为k，它大于任何其它节点的度数。

下面对这几个性质进行简单说明：
[性质一] Bk共有2k个节点。
               如上图所示，B0有20=1节点，B1有21=2个节点，B2有22=4个节点，...
[性质二] Bk的高度为k。
               如上图所示，B0的高度为0，B1的高度为1，B2的高度为2，...
[性质三] Bk在深度i处恰好有C(k,i)个节点，其中i=0,1,2,...,k。
              C(k,i)是高中数学中阶乘元素，例如，C(10,3)=(10*9*8) / (3*2*1)=240
              B4中深度为0的节点C(4,0)=1
              B4中深度为1的节点C(4,1)= 4 / 1 = 4
              B4中深度为2的节点C(4,2)= (4*3) / (2*1) = 6
              B4中深度为3的节点C(4,3)= (4*3*2) / (3*2*1) = 4
              B4中深度为4的节点C(4,4)= (4*3*2*1) / (4*3*2*1) = 1
             合计得到B4的节点分布是(1,4,6,4,1)。
[性质四] 根的度数为k，它大于任何其它节点的度数。
              节点的度数是该结点拥有的子树的数目。
              
 #二项堆
 二项堆通常被用来实现优先队列，它堆是指满足以下性质的二项树的集合：
(01) 每棵二项树都满足最小堆性质。即，父节点的关键字 <= 它的孩子的关键字。
(02) 不能有两棵或以上的二项树具有相同的度数(包括度数为0)。换句话说，具有度数k的二项树有0个或1个。
 
 ##
 上图就是一棵二项堆，它由二项树B0、B2和B3组成。对比二项堆的定义：(01)二项树B0、B2、B3都是最小堆；(02)二项堆不包含相同度数的二项树。

二项堆的第(01)个性质保证了二项堆的最小节点是某一棵二项树的根节点，第(02)个性质则说明结点数为n的二项堆最多只有log{n} + 1棵二项树。实际上，将包含n个节点的二项堆，表示成若干个2的指数和(或者转换成二进制)，则每一个2个指数都对应一棵二项树。例如，13(二进制是1101)的2个指数和为13=23 + 22 + 20, 因此具有13个节点的二项堆由度数为3, 2, 0的三棵二项树组成。

##基本定义
#ifndef _BINOMIAL_HEAP_H_
#define _BINOMIAL_HEAP_H_

typedef int Type;

typedef struct _BinomialNode{
    Type   key;                     // 关键字(键值)
    int degree;                     // 度数
    struct _BinomialNode *child;    // 左孩子
    struct _BinomialNode *parent;   // 父节点
    struct _BinomialNode *next;     // 兄弟
}BinomialNode, *BinomialHeap;

// 新建key对应的节点，并将其插入到二项堆中。
BinomialNode* binomial_insert(BinomialHeap heap, Type key);
// 删除节点：删除键值为key的节点，并返回删除节点后的二项树
BinomialNode* binomial_delete(BinomialHeap heap, Type key);
// 将二项堆heap的键值oldkey更新为newkey
void binomial_update(BinomialHeap heap, Type oldkey, Type newkey);

// 合并二项堆：将h1, h2合并成一个堆，并返回合并后的堆
BinomialNode* binomial_union(BinomialHeap h1, BinomialHeap h2) ;

// 查找：在二项堆中查找键值为key的节点
BinomialNode* binomial_search(BinomialHeap heap, Type key);
// 获取二项堆中的最小节点
BinomialNode* binomial_minimum(BinomialHeap heap) ;
// 移除最小节点，并返回移除节点后的二项堆
BinomialNode* binomial_extract_minimum(BinomialHeap heap);

// 打印"二项堆"
void binomial_print(BinomialHeap heap);

#endif

##2. 合并操作
medar.jpg
合并操作是二项堆的重点，二项堆的添加操作也是基于合并操作来实现的。

合并两个二项堆，需要的步骤概括起来如下：
(01) 将两个二项堆的根链表合并成一个链表。合并后的新链表按照"节点的度数"单调递增排列。
(02) 将新链表中"根节点度数相同的二项树"连接起来，直到所有根节点度数都不相同。
合并函数binomial_union(h1, h2)的作用是将h1和h2合并，并返回合并后的二项堆。在binomial_union(h1, h2)中，涉及到了两个函数binomial_merge(h1, h2)和binomial_link(child, heap)。
binomial_merge(h1, h2)就是我们前面所说的"两个二项堆的根链表合并成一个链表，合并后的新链表按照'节点的度数'单调递增排序"。
binomial_link(child, heap)则是为了合并操作的辅助函数，它的作用是将"二项堆child的根节点"设为"二项堆heap的左孩子"，从而将child整合到heap中去。

        在binomial_union(h1, h2)中对h1和h2进行合并时；首先通过 binomial_merge(h1, h2) 将h1和h2的根链表合并成一个"按节点的度数单调递增"的链表；然后进入while循环，对合并得到的新链表进行遍历，将新链表中"根节点度数相同的二项树"连接起来，直到所有根节点度数都不相同为止。在将新联表中"根节点度数相同的二项树"连接起来时，可以将被连接的情况概括为4种。
x是根链表的当前节点，next_x是x的下一个(兄弟)节点。
Case 1: x->degree != next_x->degree
             即，"当前节点的度数"与"下一个节点的度数"相等时。此时，不需要执行任何操作，继续查看后面的节点。
Case 2: x->degree == next_x->degree == next_x->next->degree
             即，"当前节点的度数"、"下一个节点的度数"和"下下一个节点的度数"都相等时。此时，暂时不执行任何操作，还是继续查看后面的节点。实际上，这里是将"下一个节点"和"下下一个节点"等到后面再进行整合连接。
Case 3: x->degree == next_x->degree != next_x->next->degree
        && x->key <= next_x->key
             即，"当前节点的度数"与"下一个节点的度数"相等，并且"当前节点的键值"<="下一个节点的度数"。此时，将"下一个节点(对应的二项树)"作为"当前节点(对应的二项树)的左孩子"。
Case 4: x->degree == next_x->degree != next_x->next->degree
        && x->key > next_x->key
             即，"当前节点的度数"与"下一个节点的度数"相等，并且"当前节点的键值">"下一个节点的度数"。此时，将"当前节点(对应的二项树)"作为"下一个节点(对应的二项树)的左孩子"。
第1步：将两个二项堆的根链表合并成一个链表
          执行完第1步之后，得到的新链表中有许多度数相同的二项树。实际上，此时得到的是对应"Case 4"的情况，"树41"(根节点为41的二项树)和"树13"的度数相同，且"树41"的键值 > "树13"的键值。此时，将"树41"作为"树13"的左孩子。
第2步：合并"树41"和"树13"
         执行完第2步之后，得到的是对应"Case 3"的情况，"树13"和"树28"的度数相同，且"树13"的键值 < "树28"的键值。此时，将"树28"作为"树13"的左孩子。
第3步：合并"树13"和"树28"
         执行完第3步之后，得到的是对应"Case 2"的情况，"树13"、"树28"和"树7"这3棵树的度数都相同。此时，将x设为下一个节点。
第4步：将x和next_x往后移
         执行完第4步之后，得到的是对应"Case 3"的情况，"树7"和"树11"的度数相同，且"树7"的键值 < "树11"的键值。此时，将"树11"作为"树7"的左孩子。
第5步：合并"树7"和"树11"
         执行完第5步之后，得到的是对应"Case 4"的情况，"树7"和"树6"的度数相同，且"树7"的键值 > "树6"的键值。此时，将"树7"作为"树6"的左孩子。
第6步：合并"树7"和"树6"

##3. 插入操作

理解了"合并"操作之后，插入操作就相当简单了。插入操作可以看作是将"要插入的节点"和当前已有的堆进行合并


##5. 更新操作
sub.jpg  addd.jpg
更新二项堆中的某个节点，就是修改节点的值，它包括两部分分："减少节点的值" 和 "增加节点的值" 。
5.1 减少节点的值

减少节点值的操作很简单：该节点一定位于一棵二项树中，减小"二项树"中某个节点的值后要保证"该二项树仍然是一个最小堆"；因此，就需要我们不断的将该节点上调。
减少操作的思想很简单，就是"保持被减节点所在二项树的最小堆性质"。

增加节点值的操作也很简单。上面说过减少要将被减少的节点不断上调，从而保证"被减少节点所在的二项树"的最小堆性质；而增加操作则是将被增加节点不断的下调，从而保证"被增加节点所在的二项树"的最小堆性质。
增加操作的思想很简单，"保持被增加点所在二项树的最小堆性质"。