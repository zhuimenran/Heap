#斜堆的介绍
斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种。和左倾堆一样，它通常也用于实现优先队列；作为一种自适应的左倾堆，它的合并操作的时间复杂度也是O(lg n)。
它与左倾堆的差别是：
(01) 斜堆的节点没有"零距离"这个属性，而左倾堆则有。
(02) 斜堆的合并操作和左倾堆的合并操作算法不同。

斜堆的合并操作
(01) 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。
(02) 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将"较小堆的根节点的右孩子"和"较大堆"进行合并。
(03) 合并后，交换新堆根节点的左孩子和右孩子。
        第(03)步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 > 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。
        
   参考：https://blog.csdn.net/huangshulang1234/article/details/79607121
        斜堆概述
斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左斜堆的一个变种。和左倾堆一样，它通常也用于实现优先队列；作为一种自适应的左斜堆，它的合并操作的时间复杂度也是O(lg n)。 
它与左斜堆的差别是： 
(1) 斜堆的节点没有”零距离”这个属性，而左斜堆则有。 
(2) 斜堆的合并操作和左倾堆的合并操作算法不同。 

斜堆的合并操作
(1) 如果一个空斜堆与一个非空斜堆合并，返回非空斜堆。 
(2) 如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点。将”较小堆的根节点的右孩子”和”较大堆”进行合并。 
(3) 合并后，交换新堆根节点的左孩子和右孩子。 
第(3)步是斜堆和左倾堆的合并操作差别的关键所在，如果是左倾堆，则合并后要比较左右孩子的零距离大小，若右孩子的零距离 > 左孩子的零距离，则交换左右孩子；最后，在设置根的零距离。

由于合并都是沿著最右路径进行的,经过合并之后,新斜堆的最右路径长度必然增加,这会影响下一次合并的效率。所以合并后，通过交换左右子树,使整棵树的最右路径长度非常小（这是启发规则）。然而斜堆不记录节点的距离,在操作时,从下往上,沿著合并的路径,在每个节点处都交换左右子树。通过不断交换左右子树,斜堆把最右路径甩向左边了。

递归实现合并

1.比较两个堆; 设p是具有更小的root的键值的堆，q是另一个堆，r是合併后的结果堆。 
2.令r的root是p（具有最小root键值），r的右子树为p的左子树。 
3.令r的左子树为p的右子树与q合併的结果。

非递归合并实现

1.把每个堆的每棵（递归意义下）最右子树切下来。这使得得到的每棵树的右子树均为空。 
2.按root的键值的升序排列这些树。 
3.迭代合併具有最大root键值的两棵树： 
1）具有次大root键值的树的右子树必定为空。把其左子树与右子树 
2）交换。现在该树的左子树为空。 
具有最大root键值的树作为具有次大root键值树的左子树。 